#include <stdio.h>
#include "util.h"
#include "symbol.h"
#include "temp.h"
#include "tree.h"
#include "absyn.h"
#include "assem.h"
#include "frame.h"
#include "graph.h"
#include "liveness.h"
#include "color.h"
#include "regalloc.h"
#include "table.h"
#include "flowgraph.h"

// Note: no fp or sp for register allocation
// TODO: instrs for allocation should not contain ebp or esp
// Idea: add interferce edge between fp and all nodes.
#define K 7
string registers[7] = {"%eax", "%ecx", "%edx", "%ebx", "%esi", "%edi", "%ebp"};

G_nodeList precolored      ;
G_nodeList initial         ;
G_nodeList simplifyWorklist;
G_nodeList freezeWorklist  ;
G_nodeList spillWorklist   ;
G_nodeList spilledNodes    ;
G_nodeList coalescedNodes  ;
G_nodeList coloredNodes    ;
G_nodeList selectStack     ; // using list as stack

Live_moveList coalescedMoves   ;
Live_moveList constrainedMoves ;
Live_moveList frozenMoves      ;
Live_moveList worklistMoves    ;
Live_moveList activeMoves      ;

G_adjSet adjSet;
G_table adjList;
G_table degree;
G_table moveList;
G_table alias;
G_table color;

int nodecnt;    // node count of the interference graph for adjSet use.


void        build(struct Live_graph liveGraph);
void        addEdge(G_node a, G_node b);
void        makeWorklist();
Live_moveList nodeMoves(G_node node);
bool        moverelated(G_node node);
void        simplify();
G_nodeList  adjacent(G_node node);
void        push(G_node node);
G_node      pop();
void        decrementDegree(G_node node);
void        enableMoves(G_nodeList nodes);
void        coalesce();
void        addWorkList(G_node node);
bool        OK(G_node t, G_node r);
bool        conservative(G_nodeList nodes);
G_node      getAlias(G_node node);
void        combine(G_node u, G_node v);
void        freeze();
void        freezeMoves(G_node u);
void        selectSpill();
Temp_map    assignColors();
Temp_tempList getUse(AS_instr instr);
Temp_tempList getDef(AS_instr instr);
void        replaceUseTemp(AS_instr* instr, Temp_temp oldtemp, Temp_temp newtemp);
void        replaceDefTemp(AS_instr* instr, Temp_temp oldtemp, Temp_temp newtemp);
void        rewriteProgram(AS_instrList* il, F_frame f);
struct RA_result RA_regAlloc(F_frame f, AS_instrList il);

//*
/* func: build
 * para: @liveGraph
 * description: initialize the graph representation from liveGraph
 *              generated by liveness analysis.
 *              initialize precolored and initial nodes. */
void build(struct Live_graph liveGraph) {
    precolored       = NULL;
    initial          = NULL;
    simplifyWorklist = NULL;
    freezeWorklist   = NULL;
    spillWorklist    = NULL;
    spilledNodes     = NULL;
    coalescedNodes   = NULL;
    coloredNodes     = NULL;
    selectStack      = NULL; // using list as stack

    coalescedMoves   = NULL;
    constrainedMoves = NULL;
    frozenMoves      = NULL;
    worklistMoves    = NULL;
    activeMoves      = NULL;

    adjList          = G_empty();
    degree           = G_empty();
    moveList         = G_empty();
    alias            = G_empty();
    color            = G_empty();

    G_graph interferenceGraph = liveGraph.graph;
    Live_moveList moves = liveGraph.moves;

    nodecnt = G_nodecount(interferenceGraph);
    G_nodeList nodes = G_nodes(interferenceGraph);
    adjSet = G_AdjSet(nodecnt);

    // precolored, color, initial
    while(nodes && nodes->head) {
        Temp_temp tmp = (Temp_temp)G_nodeInfo(nodes->head);
        if (tmp == F_EAX()) {
            precolored = G_NodeList(nodes->head, precolored);
            G_enter(color, nodes->head, (void *)0);
        } else if (tmp == F_ECX()){
            precolored = G_NodeList(nodes->head, precolored);
            G_enter(color, nodes->head, (void *)1);
        } else if (tmp == F_EDX()){
            precolored = G_NodeList(nodes->head, precolored);
            G_enter(color, nodes->head, (void *)2);
        } else if (tmp == F_EBX()){
            precolored = G_NodeList(nodes->head, precolored);
            G_enter(color, nodes->head, (void *)3);
        } else if (tmp == F_ESI()){
            precolored = G_NodeList(nodes->head, precolored);
            G_enter(color, nodes->head, (void *)4);
        } else if (tmp == F_EDI()){
            precolored = G_NodeList(nodes->head, precolored);
            G_enter(color, nodes->head, (void *)5);
        } else if (tmp == F_FP()){
            precolored = G_NodeList(nodes->head, precolored);
            G_enter(color, nodes->head, (void *)6);
        } else
            initial = G_NodeList(nodes->head, initial);
        nodes = nodes->tail;
    }

    // make graph representation, initialize alias
    nodes = G_nodes(interferenceGraph);
    while(nodes && nodes->head) {
        G_nodeList adjs = G_adj(nodes->head);
        G_batchAddAdjSet(adjSet, nodes->head, adjs, nodecnt);
        G_enter(adjList, nodes->head, adjs);
        G_enter(degree, nodes->head, (void *)G_degree(nodes->head));
        G_enter(alias, nodes->head, nodes->head);
        nodes = nodes->tail;
    }

    // make movelist and worklistmoves
    while(moves && moves->src && moves->dst) {
        G_enter(moveList, moves->src, Live_MoveList(moves->src, moves->dst, (Live_moveList)G_look(moveList, moves->src)));
        G_enter(moveList, moves->dst, Live_MoveList(moves->src, moves->dst, (Live_moveList)G_look(moveList, moves->dst)));
        worklistMoves = Live_MoveList(moves->src, moves->dst, worklistMoves);
        moves = moves->tail;
    }
}

// update adjSet, adjList and degree
void addEdge(G_node a, G_node b) {
    if (a != b && !G_inAdjSet(adjSet, G_nodekey(a), G_nodekey(b), nodecnt)) {
        G_addAdjSet(adjSet, G_nodekey(a), G_nodekey(b), nodecnt);
        if (!G_inNodeList(a, precolored)) {
            G_nodeList aAdjList = (G_nodeList)G_look(adjList, a);
            G_enter(adjList, a, G_NodeList(b, aAdjList));
        }
        if (!G_inNodeList(b, precolored)) {
            G_nodeList bAdjList = (G_nodeList)G_look(adjList, b);
            G_enter(adjList, b, G_NodeList(a, bAdjList));
        }
        G_enter(degree, a, (void *)((int)G_look(degree, a) + 1));
        G_enter(degree, b, (void *)((int)G_look(degree, b) + 1));
    }
}

/* func: makeWorklist
 * description: initialize spill, freeze, simplify worklist. */
void makeWorklist() {
    G_nodeList ini = initial;
    while (ini && ini->head) {
        if ((int)G_look(degree, ini->head) >= K)
            spillWorklist = G_NodeList(ini->head, spillWorklist);
        else if (moverelated(ini->head))
            freezeWorklist = G_NodeList(ini->head, freezeWorklist);
        else
            simplifyWorklist = G_NodeList(ini->head, simplifyWorklist);
        ini = ini->tail;
    }
    initial = NULL;
}

Live_moveList nodeMoves(G_node node) {
    return intersectMoveList((Live_moveList)G_look(moveList, node),
                              unionMoveList(activeMoves, worklistMoves));
}

bool moverelated(G_node node) {
    return !(nodeMoves(node) == NULL);
}

/* func: simplify
 * description: simplify a node in simplifyWorklist. */
void simplify() {
    if (!simplifyWorklist)
        return;
    G_node node = simplifyWorklist->head;
    simplifyWorklist = simplifyWorklist->tail;
    push(node);
    G_nodeList adjs = adjacent(node);
    while (adjs && adjs->head) {
        decrementDegree(adjs->head);
        adjs = adjs->tail;
    }
}

G_nodeList adjacent(G_node node) {
    return diffNodeList((G_nodeList)G_look(adjList, node),
                         unionNodeList(selectStack, coalescedNodes));
}

// push node to selectStack
void push(G_node node) {
    selectStack = G_NodeList(node, selectStack);
}

// pop node from selectStack
G_node pop() {
    if (selectStack && selectStack->head) {
        G_node node = selectStack->head;
        selectStack = selectStack->tail;
        return node;
    } else
        return NULL;
}

// decrement degree, update status,
// enable potential coalescable moves
void decrementDegree(G_node node) {
    int prevDegree = (int)G_look(degree, node);
    G_enter(degree, node, (void *)(prevDegree-1));
    if (prevDegree == K) {
        enableMoves(G_NodeList(node, adjacent(node)));
        removeFromNodeList(&spillWorklist, node);
        if (moverelated(node))
            freezeWorklist = G_NodeList(node, freezeWorklist);
        else
            simplifyWorklist = G_NodeList(node, simplifyWorklist);
    }
}

// TODO: duplicate in moves (from adjacent to movelists) // oh, nothing.
void enableMoves(G_nodeList nodes) {
    G_nodeList nodeList = nodes;
    while (nodeList && nodeList->head) {
        Live_moveList moves = nodeMoves(nodeList->head);
        while (moves && moves->src && moves->dst) {
            if (findAndRemoveFromMoveList(moves->src, moves->dst, &activeMoves))
                worklistMoves = Live_MoveList(moves->src, moves->dst, worklistMoves);
            moves = moves->tail;
        }
        nodeList = nodeList->tail;
    }
}

/* func: coalesce
 * description: coalesce a potential coalescable move in worklistMoves. */
void coalesce() {
    if (!worklistMoves)
        return;
    G_node src = worklistMoves->src;
    G_node dst = worklistMoves->dst;
    G_node x = getAlias(src);
    G_node y = getAlias(dst);
    G_node u, v;
    if (G_inNodeList(y, precolored)) {
        u = y;
        v = x;
    } else {
        u = x;
        v = y;
    }
    worklistMoves = worklistMoves->tail;

    if (u == v) {
        coalescedMoves = Live_MoveList(src, dst, coalescedMoves);
        addWorkList(u);
    } else if (G_inNodeList(v, precolored) ||
               G_inAdjSet(adjSet, G_nodekey(u), G_nodekey(v), nodecnt)) {
        constrainedMoves = Live_MoveList(src, dst, constrainedMoves);
        addWorkList(u);
        addWorkList(v);
    } else if (G_inNodeList(u, precolored)) {
        bool flag = TRUE;
        G_nodeList adjs = adjacent(v);
        while (adjs && adjs->head) {
            if (!OK(adjs->head, u))
                flag = FALSE;
            adjs = adjs->tail;
        }
        if (flag) {
            coalescedMoves = Live_MoveList(src, dst, coalescedMoves);
            combine(u, v);
            addWorkList(u);
        } else
            activeMoves = Live_MoveList(src, dst, activeMoves);
    } else {
        if (conservative(unionNodeList(adjacent(u), adjacent(v)))) {
            coalescedMoves = Live_MoveList(src, dst, coalescedMoves);
            combine(u, v);
            addWorkList(u);
        } else
            activeMoves = Live_MoveList(src, dst, activeMoves);
    }
}

// move node from freezeWorklist to simplifyWorklist
// if it is not move-related any more
void addWorkList(G_node node) {
    if (!G_inNodeList(node, precolored) && !moverelated(node) && ((int)G_look(degree, node) < K)) {
        removeFromNodeList(&freezeWorklist, node);
        simplifyWorklist = G_NodeList(node, simplifyWorklist);
    }
}

// George
// r is precolored
bool OK(G_node t, G_node r) {
    return (((int)G_look(degree, t) < K) ||
            G_inNodeList(t, precolored)  ||
            G_inAdjSet(adjSet, G_nodekey(t), G_nodekey(r), nodecnt));
}

// Briggs
bool conservative(G_nodeList nodes) {
    G_nodeList nodeList = nodes;
    int cnt = 0;
    while(nodeList && nodeList->head) {
        if ((int)G_look(degree, nodeList->head) >= K)
            cnt++;
        nodeList = nodeList->tail;
    }
    return (cnt < K);
}

G_node getAlias(G_node node) {
    G_node n = (G_node)G_look(alias, node);
    if (n == node)
        return node;
    else {
        G_node a = getAlias(n);
        G_enter(alias, node, a);
        return a;
    }
}

// add v to coalescedNodes, set alias
// add moves and adjacent of v to u
// update status of u
void combine(G_node u, G_node v) {
    if (G_inNodeList(v, freezeWorklist))
        removeFromNodeList(&freezeWorklist, v);
    else
        removeFromNodeList(&spillWorklist, v);
    coalescedNodes = G_NodeList(v, coalescedNodes);
    G_enter(alias, v, u);

    Live_moveList uMoveList = (Live_moveList)G_look(moveList, u);
    Live_moveList vMoveList = (Live_moveList)G_look(moveList, v);
    G_enter(moveList, u, unionMoveList(uMoveList, vMoveList));

    G_nodeList adjs = adjacent(v);
    while (adjs && adjs->head) {
        addEdge(adjs->head, u);
        decrementDegree(adjs->head);
        adjs = adjs->tail;
    }

    if (((int)G_look(degree, u) >= K) && G_inNodeList(u, freezeWorklist)) {
        removeFromNodeList(&freezeWorklist, u);
        spillWorklist = G_NodeList(u, spillWorklist);
    }
}

/* func: freeze
 * description: freeze a node and all its moves. */
void freeze() {
    if (!freezeWorklist)
        return;
    G_node node = freezeWorklist->head;
    freezeWorklist = freezeWorklist->tail;
    simplifyWorklist = G_NodeList(node, simplifyWorklist);
    freezeMoves(node);
}

// freeze any move related to the node.
// if result in some node not move-related any more, update their status
void freezeMoves(G_node u) {
    Live_moveList moveList = nodeMoves(u);
    while (moveList && moveList->src && moveList->dst) {
        G_node v;
        if (getAlias(moveList->dst) == getAlias(u))
            v = getAlias(moveList->src);
        else
            v = getAlias(moveList->dst);

        findAndRemoveFromMoveList(moveList->src, moveList->dst, &activeMoves);
        frozenMoves = Live_MoveList(moveList->src, moveList->dst, frozenMoves);

        if (!moverelated(v) && ((int)G_look(degree, v) < K)) {
            removeFromNodeList(&freezeWorklist, v);
            simplifyWorklist = G_NodeList(v, simplifyWorklist);
        }
        moveList = moveList->tail;
    }
}

/* func: selectSpill
 * description: spill a node from spillWorklist. */
void selectSpill() {
    // TODO: choose spill node according to algorithm.
    if (!spillWorklist)
        return;
    G_node node = spillWorklist->head;
    spillWorklist = spillWorklist->tail;
    simplifyWorklist = G_NodeList(node, simplifyWorklist);
    freezeMoves(node);
}

/* func: assignColors
 * description: assign colors for the interference graph,
                generating spilledNodes. */
Temp_map assignColors() {
    Temp_map temp_map = Temp_empty();
    while (selectStack) {
        G_node node = pop();
        int okColors[K] = {1};
        G_nodeList adjs = (G_nodeList)G_look(adjList, node);
        while (adjs && adjs->head) {
            if (G_inNodeList(getAlias(adjs->head), unionNodeList(coloredNodes, precolored))) {
                okColors[(int)G_look(color, getAlias(adjs->head))] = 0;
            }
            adjs = adjs->tail;
        }
        int i;
        bool flag = FALSE;
        for (i = 0; i < K; i++) {
            if (okColors[i] == 1) {
                coloredNodes = G_NodeList(node, coloredNodes);
                G_enter(color, node, (void *)i);
                Temp_enter(temp_map, (Temp_temp)G_nodeInfo(node), registers[i]);
                flag = TRUE;
                break;
            }
        }
        if (flag == FALSE) {
            spilledNodes = G_NodeList(node, spilledNodes);
        }
    }
    G_nodeList coalesced = coalescedNodes;
    while (coalesced && coalesced->head) {
        int color_num = (int)G_look(color, getAlias(coalesced->head));
        G_enter(color, coalesced->head, (void *)color_num);
        Temp_enter(temp_map, (Temp_temp)G_nodeInfo(coalesced->head), registers[color_num]);

        coalesced = coalesced->tail;
    }

    return temp_map;
}

//*
Temp_tempList getUse(AS_instr instr) {
    switch(instr->kind) {
        case I_OPER:
            return instr->u.OPER.src;
        case I_LABEL:
            return NULL;
        case I_MOVE:
            return instr->u.MOVE.src;
    }
    assert(0); /* cannot reach here */
}

//*
Temp_tempList getDef(AS_instr instr) {
    switch (instr->kind) {
        case I_OPER:
            return instr->u.OPER.dst;
        case I_LABEL:
            return NULL;
        case I_MOVE:
            return instr->u.MOVE.dst;
    }
    assert(0); /* cannot reach here */
}

//*
void replaceUseTemp(AS_instr* instr, Temp_temp oldtemp, Temp_temp newtemp) {
    Temp_tempList uses = getUse(*instr);
    Temp_findAndReplace(&uses, oldtemp, newtemp);
    switch((*instr)->kind) {
        case I_OPER: {
            (*instr)->u.OPER.src = uses;
            return;
        }
        case I_LABEL: {
            return;
        }
        case I_MOVE: {
            (*instr)->u.MOVE.src = uses;
            return;
        }
    }
    assert(0); /* cannot reach here */
}

//*
void replaceDefTemp(AS_instr* instr, Temp_temp oldtemp, Temp_temp newtemp) {
    Temp_tempList defs = getDef(*instr);
    Temp_findAndReplace(&defs, oldtemp, newtemp);
    switch((*instr)->kind) {
        case I_OPER: {
            (*instr)->u.OPER.dst = defs;
            return;
        }
        case I_LABEL:
            return;
        case I_MOVE: {
            (*instr)->u.MOVE.dst = defs;
            return;
        }
    }
    assert(0); /* cannot reach here */
}

/* func: rewriteProgram
 * para: @il, modify the instrList
         @f, frame to alloc for spill nodes
 * description: rewrite the instrList given spilled nodes. */
void rewriteProgram(AS_instrList* il, F_frame f) {
    char* inst1 = checked_malloc(80);
    char* inst2 = checked_malloc(80);
    G_nodeList nodes = spilledNodes;
    while (nodes && nodes->head) {
        G_node node = nodes->head;
        Temp_temp oldtemp = (Temp_temp)G_nodeInfo(node);
        AS_instrList instrs = *il;
        AS_instrList last = NULL;
        int offset = F_allocSpill(f);
        while (instrs && instrs->head) {
            if (Temp_tempInList(getUse(instrs->head), oldtemp)) {
                Temp_temp r = Temp_newtemp();
                sprintf(inst1, "movl $%d(`s0), `d0\n", offset);
                AS_instr loadinstr = AS_Oper(inst1, Temp_TempList(r, NULL), Temp_TempList(F_FP(), NULL), NULL);
                replaceUseTemp(&(instrs->head), oldtemp, r);
                if (!last)
                    *il = AS_InstrList(loadinstr, *il);
                else
                    last->tail = AS_InstrList(loadinstr, instrs);
            }

            if (Temp_tempInList(getDef(instrs->head), oldtemp)) {
                Temp_temp r = Temp_newtemp();
                sprintf(inst2, "movl `s0, $%d(`d0)\n", offset);
                AS_instr storeinstr = AS_Oper(inst2, Temp_TempList(F_FP(), NULL), Temp_TempList(r, NULL), NULL);
                replaceDefTemp(&(instrs->head), oldtemp, r);
                instrs->tail = AS_InstrList(storeinstr, instrs->tail);
            }
            last = instrs;
            instrs = instrs->tail;
        }
        nodes = nodes->tail;
    }
}

struct RA_result RA_regAlloc(F_frame f, AS_instrList il) {
    AS_instrList instrList = il;
    Temp_map coloring;

    int flag = FALSE;
    while (!flag) {
        // liveness analysis, Build
        G_graph flowGraph = FG_AssemFlowGraph(instrList, f);
        struct Live_graph liveGraph = Live_liveness(flowGraph);

        build(liveGraph);
        makeWorklist();
        while (simplifyWorklist || worklistMoves || freezeWorklist || spillWorklist) {
            if (simplifyWorklist)
                simplify();
            else if (worklistMoves)
                coalesce();
            else if (freezeWorklist)
                freeze();
            else if (spillWorklist)
                selectSpill();
        }

        coloring = assignColors();

        if (spilledNodes)
            rewriteProgram(&instrList, f);
        else
            flag = TRUE;
    }

	struct RA_result ret;
    ret.coloring = coloring;
    ret.il = instrList;
	return ret;
}
